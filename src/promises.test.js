const getRandomValue = (min = 0, max = 1) => {
  return (
    new Promise((resolve) => {
      const randomInteger = Math.random() * (max-min) + min;
      resolve(randomInteger);
    })
  ) 
};

describe('getRandomValue', () => {
  it('returns a promise of a random integer', () => {
    getRandomValue().then(value => assert.isNumber(value));
  });
});

describe('getFourRandomValues', () => {
  const getFourRandomValues = (min, max) => {
    //will hold the random values temporarily 
    let arrayOfRandom=[];
    /*I didn't want to modify the params of the initial function in order to stay within the limits of the given instructions,
    however, If I were writing this from scratch, I would add a third param to represent the amount of random values I want to get back and 
    use that as my stop condition in the loop*/
    for(let i=0; i<4; i++){
      arrayOfRandom.push(getRandomValue(min, max));
    }

    return Promise.all(arrayOfRandom)
    //technically this is returning a promise object but the test was written with a .then()
    
  };

  it('returns an array of four integers, generated by getRandomValue()', () => {
    getFourRandomValues().then(values => assert.lengthOf(values, 4));
  });
});
